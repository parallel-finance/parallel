#![cfg_attr(not(feature = "std"), no_std)]

use codec::{Decode, Encode};
use sp_core::crypto::KeyTypeId;
use sp_std::{prelude::*};
use frame_system::{
	ensure_signed,
	offchain::{CreateSignedTransaction, Signer, AppCrypto, SendSignedTransaction,},
};
use frame_support::{
    debug, decl_error, decl_event, decl_module, dispatch::DispatchResult,StorageMap,
};
use sp_runtime::{
	offchain as rt_offchain,
    offchain::storage_lock::{BlockAndTime, StorageLock},
    RuntimeDebug,
};

//TODO add to runtime
pub const KEY_TYPE: KeyTypeId = KeyTypeId(*b"pool");
pub const LOCK_TIMEOUT_EXPIRATION: u64 = 20000; // in milli-seconds
pub const LOCK_BLOCK_EXPIRATION: u32 = 10; // in block number

use pallet_ocw_oracle;
use pallet_loans;
use primitives::*;
//cargo check -p pallet-liquidate
pub mod crypto {
	use super::KEY_TYPE;
	use sp_runtime::{
		app_crypto::{app_crypto, sr25519},
		traits::Verify, MultiSignature, MultiSigner,
	};
	use sp_core::sr25519::Signature as Sr25519Signature;
	app_crypto!(sr25519, KEY_TYPE);

	pub struct TestAuthId;
	impl frame_system::offchain::AppCrypto<MultiSigner, MultiSignature> for TestAuthId {
		type RuntimeAppPublic = Public;
		type GenericSignature = sp_core::sr25519::Signature;
		type GenericPublic = sp_core::sr25519::Public;
	}

	impl frame_system::offchain::AppCrypto<<Sr25519Signature as Verify>::Signer, Sr25519Signature> for TestAuthId {
		type RuntimeAppPublic = Public;
		type GenericSignature = sp_core::sr25519::Signature;
		type GenericPublic = sp_core::sr25519::Public;
	}
}

type TotalSumPirce = Balance;
type LiquidationThreshold = Balance;
type DebtAccountBook = (CurrencyId, Balance, Price, TotalSumPirce);
type CollateralsAccountBook = (CurrencyId, Balance, Price, TotalSumPirce, LiquidationThreshold);

// type Borrower = Config::AccountId;
// the borrower's debt, like DAI/USDT
type LiquidateToken = CurrencyId;
// the borrower's collateral, like BTC/KSM/DOT
type CollateralToken = CurrencyId;
// the amount of liquidate_token (such as DAI/USDT)
type RepayAmount = Balance;

/// store info that need to be liquidated
#[derive(Encode, Decode, Clone, PartialEq, Eq, RuntimeDebug)]
pub struct WaitingForLiquidation<AccountId>(AccountId, LiquidateToken, CollateralToken, RepayAmount);

pub trait Config: CreateSignedTransaction<Call<Self>> + pallet_loans::Config {
    /// The identifier type for an offchain worker.
    type AuthorityId: AppCrypto<Self::Public, Self::Signature>;
    /// The overarching event type.
    type Event: From<Event<Self>> + Into<<Self as frame_system::Config>::Event>;
    /// The overarching dispatch call type.
    type Call: From<Call<Self>>;
}

decl_event!(
    /// Events generated by the module.
    pub enum Event<T>
    where
        AccountId = <T as frame_system::Config>::AccountId,
    {
        LiquidationOccur(AccountId, u128),
    }
);

decl_error! {
    pub enum Error for Module<T: Config> {
        /// error
		CaculateError,
		OracleCurrencyPriceNotReady,
    }
}

decl_module! {
    /// A public part of the pallet.
    pub struct Module<T: Config> for enum Call where origin: T::Origin {
        fn deposit_event() = default;

		#[weight = 10000 ]
		fn execute_liquidation(origin, waiting_for_liquidation_vec: Vec<WaitingForLiquidation<T::AccountId>>)-> DispatchResult {
			let who = ensure_signed(origin)?;
			for i in 0..waiting_for_liquidation_vec.len() {
				let waiting_for_liquidation = waiting_for_liquidation_vec[i].clone();
				let borrower = waiting_for_liquidation.0;
				let liquidate_token = waiting_for_liquidation.1;
				let collateral_token = waiting_for_liquidation.2;
				let repay_amount = waiting_for_liquidation.3;
				let r = pallet_loans::Pallet::<T>::liquidate_borrow_internal(who.clone(), borrower, liquidate_token, repay_amount, collateral_token);
				match r {
					Ok(_) => debug::info!("success liquidate"),
					Err(_) => continue
				}
			}
			// fixme trigger event
			Self::deposit_event(Event::<T>::LiquidationOccur(who, waiting_for_liquidation_vec.len() as u128));
			Ok(().into())
		}

        fn offchain_worker(block_number: T::BlockNumber) {
			debug::info!("Check liquidation in OCW");
			Self::liquidate(block_number);
		}
    }
}

impl<T: Config> Module<T> {
	// Start new round of offchain worker
	fn liquidate(_block_number: T::BlockNumber) {
		//must have a lock
		let mut lock = StorageLock::<BlockAndTime<Self>>::with_block_and_time_deadline(
            b"offchain-liquidate::lock",
            LOCK_BLOCK_EXPIRATION,
            rt_offchain::Duration::from_millis(LOCK_TIMEOUT_EXPIRATION),
        );
		if let Err(_guard) = lock.try_lock() {
			debug::error!("offchain_worker error: get lock failed");
			return;
		}
		// 1 get all borrowers
		let mut borrowers:Vec<T::AccountId> = vec![];
		for currency_id in pallet_loans::Currencies::<T>::get().iter() {
			let mut v = pallet_loans::AccountBorrows::<T>::iter_prefix(currency_id)
				.map(|(x,_)| x)
				.filter(|x| !borrowers.contains(x))
				.collect::<Vec<T::AccountId>>();
			borrowers.append(&mut v);
		}
		debug::info!("all borrowers are: {:?}", borrowers);

		// we execute liquidation with borrowers one by one
		for borrower in borrowers.into_iter() {
			// 2.1 get debts by currency
			let mut classify_debts:Vec<DebtAccountBook> = vec![];
			// 2.2 get collaterals by currency
			let mut classify_collaterals:Vec<CollateralsAccountBook> = vec![];

			for currency_id in pallet_loans::Currencies::<T>::get().iter() {
				let (currency_price, _) = 
					match pallet_ocw_oracle::Prices::get(currency_id)
						.ok_or(Error::<T>::OracleCurrencyPriceNotReady){
							Ok(v) => v,
							Err(_e) => continue
					};

				///////////// 2.1.1 insert debt by currency
				let borrow_currency_amount =
					match pallet_loans::Pallet::<T>::borrow_balance_stored(&borrower, currency_id){
						Ok(v) => v,
						Err(_e) => continue
					};
				let borrow_currency_sum_price = 
					match borrow_currency_amount
						.checked_mul(currency_price)
						.ok_or(Error::<T>::CaculateError){
							Ok(v) => v,
							Err(_e) => continue
						};
				classify_debts.push((*currency_id,borrow_currency_amount,currency_price,borrow_currency_sum_price));

				// this is why we need distinguish token and cToken, though we have not yet!
				// error-prone
				/////////////2.2.1 insert collateral by currency
				let collateral_ctoken_amount = pallet_loans::AccountCollateral::<T>::get(currency_id, &borrower);
				let exchange_rate = pallet_loans::ExchangeRate::<T>::get(currency_id);
				//the total amount of borrower's collateral token
				let collateral_currency_amount = 
					match collateral_ctoken_amount.checked_mul(exchange_rate)
							.and_then(|r| r.checked_div(RATE_DECIMAL))
							.ok_or(Error::<T>::CaculateError){
								Ok(v) => v,
								Err(_e) => continue
					};
				//the total price of borrower's collateral token
				let collateral_currency_sum_price = 
					match collateral_currency_amount.checked_mul(currency_price).ok_or(Error::<T>::CaculateError) {
						Ok(v) => v,
						Err(_e) => continue
					};
					
				let liquidation_threshold = pallet_loans::LiquidationThreshold::<T>::get(currency_id);
				classify_collaterals.push((*currency_id,collateral_currency_amount,currency_price,collateral_currency_sum_price,liquidation_threshold));
			}

			// 3 check liquidation threshold
			// if (collateral_total_value * liquidation_threshold)/(debt_total_value) < 1 ,execute liquidation
			let collateral_liquidation_threshold_value = classify_collaterals.iter()
				.fold(0 as Balance,
					|acc,&(_,_,_,total_sum_price,liquidation_threshold)| 
					acc + total_sum_price * liquidation_threshold
				);// FIXME liquidation_threshold is "8 * RATE_DECIMAL / 10"
			
			let debt_total_value = classify_debts.iter()
				.fold(0 as Balance, 
					|acc, &(_,_,_,total_sum_price)| 
					acc + total_sum_price
				);
			
			// 4 no need liquidate
			if collateral_liquidation_threshold_value / (debt_total_value * RATE_DECIMAL) > 1 {
				continue;
			}

			// 5 liquidation strategy:
			// since total debt doesn't depend on single currency, it depends on all currencies' total value
			// we will liquidate as following:
			// Suppose borrower has three collateral（BTC\KSM\DOT），and thier sum-price ratio is(5:3:2)
			// then we divide this borrower's debt in this ratio(5:3:2),liquidate each collateral respectively.
			// !!! what's important 
			//////////////////////////////////
			// the liquidation pool must have enough assets
			let mut waiting_for_liquidation_vec: Vec<WaitingForLiquidation<T::AccountId>> = vec![];

			let collateral_total_value = classify_collaterals.iter()
				.fold(0 as Balance,
					|acc,&(_,_,_,total_sum_price,_)| 
					acc + total_sum_price 
				);
			for &(liquidate_token,debt_repay_amount,_,_debt_total_sum_price) in classify_debts.iter() {
				//CollateralsAccountBook = (CurrencyId, Balance, Price, TotalSumPirce, LiquidationThreshold);
				for &(collateral_token,_,_,single_collateral_total_sum_pirce,_) in classify_collaterals.iter(){
					let repay_amount = debt_repay_amount * single_collateral_total_sum_pirce / collateral_total_value;
					waiting_for_liquidation_vec.push(WaitingForLiquidation(borrower.clone(),liquidate_token,collateral_token,repay_amount));
				}
			}
			//liquidate a single user every time
			Self::offchain_signed_tx(borrower.clone(), waiting_for_liquidation_vec);
		}
	}

	// Sign the query result
	fn offchain_signed_tx(borrower: T::AccountId, waiting_for_liquidation_vec: Vec<WaitingForLiquidation<T::AccountId>>) {
		debug::info!("send liquidation tx, borrower is: {:?}", &borrower);
		// Get signer from ocw
		//TODO get special pool account
		let signer = Signer::<T, T::AuthorityId>::any_account();
		let result = signer.send_signed_transaction(|_acct|
			// This is the on-chain function
			Call::execute_liquidation(waiting_for_liquidation_vec.clone())
		);

		// Display error if the signed tx fails.
		if let Some((acc, res)) = result {
			if res.is_err() {
				debug::error!("failure: offchain_signed_tx: tx sent: {:?}", acc.id);
			} else {
				debug::info!("successful: offchain_signed_tx: tx sent: {:?} index is {:?}", acc.id, acc.index);
			}
		} else {
			debug::error!("No local account available");
		}
	}
}

impl<T: Config> rt_offchain::storage_lock::BlockNumberProvider for Module<T> {
    type BlockNumber = T::BlockNumber;
    fn current_block_number() -> Self::BlockNumber {
        <frame_system::Module<T>>::block_number()
    }
}